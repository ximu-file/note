# 查询性能优化



如果我们将一次查询看成很多个子任务，那么我们优化查询的方式要么是消除或则减少子任务的数量，要么让子任务运行的更快。



# 1. 慢查询基础：优化数据访问

所谓优化数据访问，也就是尽可能的只检索我们所需要的数据行，不做无效的检索，主要分为两点：

1. 是否向数据库请求了不需要的数据；
2. MySQL是否在扫描额外的记录。



下面针对这两种情形给出实例分析：

## 1.1 向数据库请求了不需要的数据

由于研发人员的大意，很多情况下我们都可能会出现向数据库请求了不需要的数据的情况，然后应用程序获得了这些冗余的数据也会丢弃，这其中也就存在很多不必要的网络IO、服务器开销，夏敏给出一些我们开发中经常碰到的经典的案例



**1）查询不需要的记录**

比如我们有一个需求是查询某个网站热点数排名前十的新闻记录，但是我们经常会出现 `select * from article order by hot desc`  这样的写法就存在很严重的问题，这个SQL会查询出所有的记录，然而我们应用只需要排名前十的数据，所以存在大量的冗余，会非常占用服务器性能。 所以合理的加上 `limit` 关键字是一个必备的意识。



简单说就是： 按需查询，时刻考虑limit



**2）多表关联时返回全部的列**

我们在写SQL时为了偷懒，经常会出现 `select *`  这是我们非常常见的写法。但是实际上我们应该根据我们实际的场景，只查询我们需要的列，这样可以大大减少网络IO，此外也有更多的可能性使用覆盖索引。



简单来说： 禁止`select * ` 只查询需要的列。



**3）重复查询相同的数据**

对于一些热点数据，可能存在大量的重复查询相同的数据，这时候走DB完全是不必要的，我们完全可以用缓存存储这些查询的结果，流量走缓存而不走DB。



简单来说：热点数据走缓存。



##1.2 MySQL是都在扫描额外的记录

在前面第一点确认了只返回了需要的数据行之后，我们应该关注查询为了返回只需要结果，是否扫描了过多的行数据(索引派上了用场)，最简单的指标就是：



- 响应时间
- 扫描的行数
- 返回的行数



**响应时间**

对于响应时间，MySQL提供了工具查看某一个SQL的执行时间，具体的使用方式见链接：

[查看mysql语句运行时间](http://www.cnblogs.com/happySmily/p/5943311.html)



**扫描的行数**

我们在分析查询时，查看该查询扫描的行数是一个非常有用的指标，一定层度上能够说明这个查询的效率。通过使用 `explain` 语句分析SQL语句， 就可以获得扫描的行数，以及访问数据的类型(使用索引或则全表扫描等等)



比如：下面实例中type列显示了扫描类型，rows显示了扫描的行数。

```mysql
mysql> explain select count(*) as cnt, education from user where education is not null group by education order by cnt desc limit 20;
+----+-------------+-------+------+---------------+------+---------+------+---------+----------------------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows    | Extra                                        |
+----+-------------+-------+------+---------------+------+---------+------+---------+----------------------------------------------+
|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL | 1460023 | Using where; Using temporary; Using filesort |
+----+-------------+-------+------+---------------+------+---------+------+---------+----------------------------------------------+
1 row in set (0.00 sec)
```





# 2. 重构查询方式

- 将一个复杂查询切分成多个简单的查询，对比两种方案性能选择最优。
- 分解关联查询



### 2.1切分查询

有时候对于一个大的查询，我们需要分而治之，将大查询划分成多个小查询。一个非常典型的例子就是数据清洗，当我们需要删除大量数据时，如果一次执行delete，则可能一次锁住大量的行，占满失误，占用资源，影响其余的查询正常工作。我们应该将一个大的delete分解成多个小的delete，这就能大大降低服务器压力。



### 2.2 分解关联查询

这一步其实也就是将一些 左链接、右连接或则内连接操作拆分成多个SQL语句。简单的单表SQL更加好实用缓存等手段提高性能。



# 3. 查询执行的原理与基础

前面讲了一些优化MySQL的SQL查询相关的知识，其实从根本上来讲，想要优化查询，我们必须知道MySQL拿到一个SQL语句之后是如何进行优化和执行查询的过程，然后我们就能从过程出发找到优化点，只要理解了优化和查询执行的过程，那么我们要做的就是更改查询让其符合MySQL优化的策略。



首先我们先用一个图示来表示当MySQL接受到一个SQL之后，MySQL做了什么？

![QQ20171103-093817@2x](../../Downloads/图片/QQ20171103-093817@2x.png)



我们可以将上图的过程分解为四大趴：

1. 客户端发送一条查询给MySQL服务器；
2. MySQL服务器首先检查查询缓存，如果命中了MySQL的查询缓存，就直接返回，不用走DB了。 (==这里有一点，什么时候MySQL会缓存查询，有什么手段可以查询缓存的SQL？==)
3. MySQL的解析器对SQL进行解析，生成解析树，然后进行预处理，再由查询优化器生成对应的查询执行计划。（==这里有几点，解析器、预处理器、查询优化器分别的工作职责是什么？==）
4. MySQL查询执行引擎调用 存储引擎的API 执行查询执行计划。



上面的四大趴，每一趴都是一个值得深入研究的地方，理解每一个地方都对查询优化理解有好处。下面分别来深入分析这几个方面



## 3.1 MySQL客户端与服务端通信

对于通信协议这一块不是SQL查询优化的重点，更多的是与通信协议相关的，对于查询优化来说我们只需要知道一些大概知识就行。



第一点：MySQL客户端和服务端之间通信协议是 **半双工** 的，这意味着在一个线程里面任何一个时刻客户端和服务端之间的数据传输是单向的，两端不能同时传输数据。



第二点：每次客户端发送查询请求给服务端后， 当服务端开始响应客户端请求，客户端就必须完整接受全部结果集然后缓存在内存中。所以我们的SQL中加上limit是多么重要。而且如果查询的是一个大的结果集，服务端也会一直被这个查询所占用资源，直到查询结束。



第三点：**查询状态**：对于一个MySQL连接(线程)，任何时刻都只有一个状态表示MySQL当前执行状态。

`show full processlist` 命令可以显示出当前所有MySQL线程的运行状态。运行状态有多种，具体解释可以参考另外一篇文章 **MySQL连接线程运行状态分析**



## 3.2 MySQL服务端**查询缓存**

这部分应用其实不多，我个人理解就是在SQL执行前的一个前置缓存，如果命中了，就直接返回结果集，不在执行SQL查询工作。查询缓存会跟踪查询中涉及到的每个表，如果这些表发生了变化，相关的查询缓存数据全部都会失效。



## 3.3 查询优化处理：解析器、预处理器、查询优化器

这一步的本质是将==SQL转换成执行计划== ，包含三个子阶段：解析SQL、预处理、优化SQL执行计划。



**解析SQL阶段**

MySQL利用关键字对SQL语句解析生成一颗对应的“解析树”，这个过程中主要利用MySQL语法规则验证、解析查询，比如是否使用错误关键字、关键字输出怒是否正确、检验引号是否匹配正确。



**预处理器**

进一步校验解析树是否合理，比如：数据表和数据列是否存在、名字和别名是否有歧义等等；



**查询优化器**

经过前面的校验，现在的语法树被认为是合法的了。那么接下来就是由优化器将其转化成执行计划。对于同一个SQL查询，可以有多种执行方式但是都返回同一个结果集。优化器的作用就是找到执行效率最高的执行方式。





## 3.4 查询执行引擎







## 3.5 返回结果集给客户端



















































































