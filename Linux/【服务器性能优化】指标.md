# 系统性能优化指标

> 主要包括 load average、





# load average 系统负载

在平时的运维工作中，当一台服务器的性能出现问题时，通常会去看当前的CPU使用情况，尤其是看下CPU的负载情况(load average)。

要想获得服务器的CPU负载情况，有下面三种命令：`w、uptime、top`

```
# w命令
root@louyuting:/opt# w
 00:37:46 up 37 days,  4:59,  1 user,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/5    112.10.80.12     00:28    3.00s  0.03s  0.00s tmux a

# uptime 命令
root@louyuting:/opt# uptime
 00:37:49 up 37 days,  4:59,  1 user,  load average: 0.00, 0.01, 0.05

# top 命令
root@louyuting:/opt#top
top - 00:38:57 up 37 days,  5:00,  1 user,  load average: 0.00, 0.01, 0.05
Tasks:  79 total,   2 running,  77 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.3 us,  0.0 sy,  0.0 ni, 98.3 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   1017812 total,   918764 used,    99048 free,    38968 buffers
KiB Swap:        0 total,        0 used,        0 free.    88252 cached Mem
。。。。

```



**首先区分一下CPU负载和CPU利用率的区别：**

1）CPU利用率：显示的是程序在运行期间实时占用的CPU百分比`

2）CPU负载：显示的是一段时间内正在使用和等待使用CPU的平均任务数。`

CPU利用率高，并不意味着负载就一定大。

举例来说：如果我有一个程序它需要一直使用CPU的运算功能，那么此时CPU的使用率可能达到100%，但是CPU

的工作负载则是趋近于“1”，因为 CPU仅负责一个工作嘛！如果同时执行这样的程序两个呢？CPU的使用率还是

100%，但是工作负载则变成2了。所以也就是说，当CPU的工作负载越大， 代表CPU必须要在不同的工作之间进

行频繁的工作切换。



**load average梳理**

load average表示的是系统的平均负荷，即CPU的Load。

它所包含的信息不是CPU的使用率状况，而是在一段时间内CPU正在处理以及等待CPU处理的进程数之和的统计信

息，也就是CPU使用队列的长度的统计信息。

它包括3个数字，分别表示系统在1、5、15分钟内进程队列中的平均进程数量（即处理的进程情况），

原则上来说这3个数字越小越好，数字越小表示服务器的工作量越小，系统负荷比较轻。



当CPU完全空闲的时候，平均负荷为0（即load average的值为0）；当CPU工作量饱和的时候，平均负荷为1。

 

这里需要注意的是：

load average这个输出值，这三个值的大小一般不能大于系统逻辑CPU的个数

比如一台服务器有4个逻辑CPU，如果load average的三个值长期大于4时，说明CPU很繁忙，负载很高，可能会影响系统性能；

但是偶尔大于4时，倒不用担心，一般不会影响系统性能。

相反，如果load average的输出值小于CPU的个数，则表示CPU还有空闲，比如本例中的输出，CPU是比较空闲的。



**load average举例理解**

判断系统负荷是否过重，必须理解load average的真正含义。假设当前我的一台服务器只有一个CPU，所有的运算都必须由这个CPU来完成。

不妨把这个CPU想象成一座大桥，桥上只有一根车道，所有车辆都必须从这根车道上通过（很显然，这座桥只能单向通行）。

1）系统负荷为0，意味着大桥上一辆车也没有。

2）系统负荷为0.5，意味着大桥一半的路段有车。

3）系统负荷为1.0，意味着大桥的所有路段都有车，也就是说大桥已经``"满"``了。但是必须注意的是，直到此时大桥还是能顺畅通行的。

4）系统负荷为1.7，意味着车辆太多了，大桥已经被占满了（100%），后面等着上桥的车辆为桥面车辆的70%。

以此类推，系统负荷2.0，意味着等待上桥的车辆与桥面的车辆一样多；

系统负荷3.0，意味着等待上桥的车辆是桥面车辆的2倍。

总之，当系统负荷大于1，后面的车辆就必须等待了；系统负荷越大，过桥就必须等得越久。

 

CPU的系统负荷，基本上等同于上面的类比。大桥的通行能力，就是CPU的最大工作量；桥梁上的车辆，就是一个个等待CPU处理的进程（process）。

如果CPU每分钟最多处理100个进程，那么：

系统负荷0.2，意味着CPU在这1分钟里只处理20个进程；

系统负荷1.0，意味着CPU在这1分钟 里正好处理100个进程；

系统负荷1.7，意味着除了CPU正在处理的100个进程以外，还有70个进程正排队等着CPU处理。

 

为了服务器顺畅运行，系统负荷最好不要超过1.0，这样就没有进程需要等待了，所有进程都能第一时间得到处理。

很显然，1.0是一个关键值，超过这个值，系统就不在最佳状态了，就需要动手干预了。 

 

**1.0是系统负荷的理想值吗？**

不一定，系统管理员往往会留一点余地，当这个值达到0.7，就应当引起注意了。

以往经验是这样的：

当系统负荷持续大于0.7，必须开始调查了，问题出在哪里，防止情况恶化。

当系统负荷持续大于1.0，必须动手寻找解决办法，把这个值降下来。

当系统负荷达到5.0，就表明系统有很严重的问题，长时间没有响应，或者接近死机了。觉不能让系统达到这个值。

  

上面，假设我的这台服务器只有1个CPU。如果它装了2个CPU，就意味着服务器的处理能力翻了一倍，能够同时处理的进程数量也翻了一倍。

还是用大桥来类比，两个CPU就意味着大桥有两根车道了，通车能力翻倍了。

所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的服务器，可接受的系统负荷最大为n。

 



**至于load average是多少才算理想，这个有争议，各有各的说法**

个人比较赞同CPU负载小于等于``"内核数乘以0.5-0.7"``算是一种理想状态。

比如4核CPU的服务器，理想负载是小于等于2，最好不要超过2.8，否则性能多少会受影响。

 

不管某个CPU的性能有多好，1秒钟能处理多少任务，可以认为它无关紧要，虽然事实并非如此。

在评估CPU负载时，只以5分钟为单位做统计任务队列长度。如果每隔5分钟统计的时候，发现任务队列长度都是1，那么CPU负载就为1。

 

假如现在某台服务器只有一个单核的CPU，负载一直为1，意味着没有任务在排队，还不错。

但是这台服务器是双核CPU，等于是有4个内核，每个内核的负载为1的话，总负载为4。这就是说，如果这台服务器的CPU负载长期保持在4左右，还可以接受。

但是每个内核的负载为1，并不能算是一种理想状态！这意味着服务器的CPU一直很忙，不得清闲。

 

 

**load average返回三个平均值应该参考哪个值？**

如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。

如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。

所以应该主要观察``"15分钟系统负荷"``，将它作为服务器正常运行的指标。

 

**如何来降低服务器的CPU负载？**

最简单办法的是更换性能更好的服务器，不要想着仅仅提高CPU的性能，那没有用，CPU要发挥出它最好的性能还需要其它软硬件的配合。

在服务器其它方面配置合理的情况下，CPU数量和CPU核心数（即内核数）都会影响到CPU负载，因为任务最终是要分配到CPU核心去处理的。两块CPU要比一块CPU好，双核要比单核好。

因此，需要记住的是：除去CPU性能上的差异，CPU负载是基于内核数来计算的。有一个说法是``"有多少内核，即有多少负载"``.